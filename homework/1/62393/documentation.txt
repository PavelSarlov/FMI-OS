Решение на задача 1:

	Интуитивното решение на задачата беше да се минава ред по ред, но лично не ми допадна колко време отнема за извличането на всички класирани. Забелязах, в началните редове има списък с всички категории и под всяка категория броя на класиралите се, затова реших да използвам това в моя полза. По-долу е описан методът ми на работа:

	1) Преглеждане на html страницата и разграничаване на отделните елементи, които са ни нужни (доверяваме се на факта, че всяка страница има възможно най-подобен код):
		1.1) датата на провеждане се съдържа в ред с клас "Title TI21";
		1.2) категориите могат да се извлечат от ред с клас "Title TI24";
		1.3) броят на класираните за всяка категория се намира в ред с клас "Title TI25";
		1.4) класираните и информацията за тях се намира в ред с клас от вида "ResLine".
	2) Извличане на данните:
		2.1) първоначално се прави проверка дали е подаден точно един аргумент и ако да - дали той е четим файл;
		2.2) започва итерация върху всеки ред от подадения файл като закоментирани редове и редове с невалидни линкове се пропускат;
		2.3) html изходът от curl командата се запазва в променлива за по-лесно ползване;
		2.4) извлича се датата от документа, която споменахме, че се намира на ред с клас "Title TI21", за обработка на формата се използва sed;
		2.5) създава се низ, в който се извличат всички категории в документа от ред с клас "Title TI24" (sed ще ни изведе 2 ненужни реда отпред и 4 отзад);
		2.6) аналогично на 2.5) се създава низ, в който се извлича гореспоменатият брой класирани;
		2.7) итерираме по всяка категория, добавяме към eRow (променлива за краен ред) текущия брой от масива, взимаме всички класирани (редове с клас ор вида "ResLine"), чрез head взимаме първите eRow реда, а с tail взимаме редовете започващи от sRow (променлива за начален ред);
		2.8) правим малко рефакторинг където се налага (премахват се полета от типа "&nbsp"; имената се разменят, ако има запетайка; някои имена са във вид на линк - таговете се премахват);
		2.9) накрая се принтира информацията в изисквания формат и към sRow се добавя текущата стойност на масива от брой класирани (тоест offset за следващата категория).

-------------------------

Решение на задача 2:

	1) Първоначално правим проверка за броя на аргументите, който трябва да е 3 или 5, както и дали файлът е четим.
	2) Спрямо подадената команда се изпълнява различно действие:
		2.1) в случай на "top_places" <cat> <n> <m>:
			2.1.1) с awk се избират имената на всички класирали се на места по-малки или равни на аргументa <n>;
			2.1.2) сортира се резултатът лексикографски;
			2.1.3) преброяват се уникалните имена;
			2.1.4) сортира се този път числено и низходящо;
			2.1.5) премахват се водещи интервали (в примера нямаше);
			2.1.6) взимат се първите <m> реда.
		2.2) в случай на "parts" <name>:
			2.2.1) с grep извеждаме редовете, съдържащи <name>;
			2.2.2) с awk извеждаме 1-вата и 2-рата колона (дата и категория);
			2.2.3) сортираме по първото поле (дата) с избрано начало на полето (първо по година, после по месец, накрая по ден);
			2.2.4) отново с awk правим таблица на категориите и съответните им дати и ги извеждаме.

------------------------

Помощни източници:

1) https://www.gnu.org/software/bash/manual/bash.html
2) man страници на използваните инструменти
