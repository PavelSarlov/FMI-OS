Малко инфо за използваните функции и т.н.:

    1. За различните кодове грешки е създаден enum ERR, както и функция errmsg(int), приемаща код на грешката, за извеждане на подходящо обяснение за проблема и терминиране на процеса.
    2. Вариадичната фунцкия output_formatted(int, uint16_t, ...), приемаща дескриптор, id на данните и аргументи на съответните данни, отговаря за форматирането на данните в human-readable формат и подаването им към дескриптора (може да се hardcode-не просто stderr, но да речем, че може да се използва и друг stream). Функцията връща 0 при успех и -1 при грешка.
    3. За четенето и писането на данните отговаря функцията rw_toaster(int, int, struct timeval), приемаща дескрипторите за вход и изход и времето на начало на програмата. Функцията връща 0 при успех и код на грешката в противен случай.
    4. За прекъсванията се използва функция suspend_thread(double), приемаща времето в секунди и приспиваща процеса за това време. Функцията връща 0 при успех и -1 при грешка.

------------------------------------------

Решение на задачата:
    
    1. В началото се инициализира времето на стартиране на програмата и се правят проверки за параметрите (техния брой и дали операцията е една от двете "record"/"replay").
    2. Навлизаме във функцията rw_toaster():
        2.1. Спрямо първите прочетени два байта определяме данните, които ще четем.
        2.2. С помощта на gettimeofday() взимаме текущото време и изчисляваме времето за изпълнение на програмата до този момент като от текущото изваждаме времето на стартиране.
        2.3. Операция "record": 
            2.3.1. Прочитат се необходимите данни спрямо id-то им.
            2.3.2. Записват се във файловия дескриптор, който в случая е log файлът, като форматът им е същия, в който са прочетени, но в края са добавени 8 байта за double, което е времевата марка на съобщението.
            2.3.3. Отделно се принтират и форматирани на stderr.
        2.4. Операция "replay":
            2.4.1. Прочитат се необходимите данни спрямо id-то им.
            2.4.2. Допълнително се чете и времевата марка (timestamp) на съобщението. Чрез нея и текущото време (curTime) се изчислява необходимото време за закъснение, което да се подаде на фунцкията suspend_thread(). Ако разликата не е положително число, процесът не се приспива.
            2.4.3. Данните се извеждат в същия формат, в който са приети, на stdout, а на stderr се принтират human-readable.
        2.5 Повтаряме процеса, докато не свършат данните или не излезне някаква грешка.

------------------------------------------

Помощни източници:

    [1] man страници на използваните функции

    [2] https://wiki.sei.cmu.edu/confluence/display/c/MSC39-C.+Do+not+call+va_arg()+on+a+va_list+that+has+an+indeterminate+value
